#!/usr/bin/env python

"Turns the subset of Python we support into virtual bytecode for Java code to run"

# We use Python's ast module for the heavy lifting.  It parses the
# target file and we then operate on the resulting abstract syntax
# tree.

import sys
import ast
import linecache

try:
    from IPython.Debugger import Tracer
    debug_here=Tracer()
    del Tracer
except ImportError:
    import pdb
    debug_here=pdb.set_trace
    del pdb

        
class Compiler(ast.NodeVisitor):

    _opmap={
        ast.Add: "+",
        ast.Mult: "*",
        ast.Div: "/",
        ast.Gt: ">",
        ast.UAdd: "++", # distinguish from unary
        }

    class Error(Exception):
        def __init__(self, node, message):
            Exception.__init__(self, message)
            self.message=message
            self.node=node

    def compile(self, inputfile, linenumbers=False):
        t=ast.parse(open(inputfile, "rb").read(), inputfile)
        ast.fix_missing_locations(t)
        res=[]
        try:
            for node,v  in self.visit(t):
                res.append( (node, v) )
        except self.Error, e:
            print >> sys.stderr, e.message,"at line",e.node.lineno,"of", inputfile
            print >> sys.stderr, linecache.getline(inputfile, e.node.lineno)+e.node.col_offset*" "+"^"
            sys.exit(2)
        final=""
        for node, v in res:
            v=unicode(v)
            if v[-1] in ('\n', ' ', ')') or len(final)==0 or final[-1]=='(':
                final+=v
                if linenumbers and node and not isinstance(node, (ast.Num, ast.Name, ast.Str)):
                    final+=":"+str(node.lineno)
            else:
                final+=" "+v
        print final.encode("utf8")
        
    def generic_visit(self, node):
        raise self.Error(node, "Unsupported syntax "+node.__class__.__name__)

    def visit_Module(self, node):
        yield None, '('
        for i in node.body:
            for x in self.visit(i):
                yield x
        yield None, ')'

    def visit_Expr(self, node):
        vals=[x for x in self.visit(node.value)]
        if len(vals)==1:
            yield vals[0]
        else:
            yield None, "("
            for x in vals:
                yield x
            yield None, ")\n"

    def visit_BinOp(self, node):
        assert len(node.op._fields)==0
        yield None, "("
        yield node, self._opmap[node.op.__class__]
        for x in self.visit(node.left):
            yield x
        for x in self.visit(node.right):
            yield x
        yield None, ")"

    def visit_UnaryOp(self, node):
        yield None, "("
        yield node, self._opmap[node.op.__class__]
        for x in self.visit(node.operand):
            yield x
        yield None, ")"

    def visit_Compare(self, node):
        if len(node.ops)!=1:
            raise self.Error(node, "Only one comparison is supported (you can't do x<y<z)")
        yield None, "("
        yield node, self._opmap[node.ops[0].__class__]
        for x in self.visit(node.left):
            yield x
        for x in self.visit(node.comparators[0]):
            yield x
        yield None, ")"

    def visit_Num(self, node):
        yield node, node.n

    def visit_Name(self, node):
        assert len(node.ctx._fields)==0
        yield node, node.id

    def visit_Str(self, node):
        yield node, '"%s"' % (node.s.replace('"', '""'),)

    def visit_List(self, node):
        assert len(node.ctx._fields)==0
        yield None, "("
        yield node, "list"
        for x in node.elts:
            for y in self.visit(x):
                yield y
        yield None, ")"

    def visit_Dict(self, node):
        yield None, "("
        yield node, "dict"
        for k,v in zip(node.keys, node.values):
            for x in self.visit(k):
                yield x
            for x in self.visit(v):
                yield x
        yield None, ")"

    def visit_Attribute(self, node):
        assert len(node.ctx._fields)==0
        yield None, "("
        yield node, "."
        for x in self.visit(node.value):
            yield x
        yield None, node.attr
        yield None, ")"

    def visit_Subscript(self, node):
        assert len(node.ctx._fields)==0
        yield None, "("
        if isinstance(node.slice, ast.Slice):
            yield node, "[:]"            
        else:
            yield node, "[]"
        for x in self.visit(node.value):
            yield x
        if isinstance(node.slice, ast.Slice):
            if node.slice.step is not None:
                raise self.Error(node.slice, "Steps not supported in slices")
            if node.slice.lower is None:
                yield None, 0
            else:
                for x in self.visit(node.slice.lower):
                    yield x
            if node.slice.upper is None:
                yield None, -1
            else:
                for x in self.visit(node.slice.upper):
                    yield x
        else:
            for x in self.visit(node.slice.value):
                yield x
        yield None, ")"

    def visit_Assign(self, node):
        if len(node.targets)!=1:
            raise self.Error(node, "Only assigning to one variable at a time is supported")
        if not isinstance(node.targets[0], ast.Name):
            debug_here()
            raise self.Error(node, "Only assigning to a single named variable is supported")
        yield None, "("
        yield node, "="
        for x in self.visit_Name(node.targets[0]):
            yield x
        for x in self.visit(node.value):
            yield x
        yield None, ")"

    def visit_Call(self, node):
        if node.starargs:
            raise self.Error(node, "*args not supported")
        if node.kwargs or node.keywords:
            raise self.Error(node, "Keyword arguments are not supported")
        yield None, "("
        yield node, "call"
        for x in self.visit(node.func):
            yield x
        for x in node.args:
            for y in self.visit(x):
                yield y
        yield None, ")"

    def visit_If(self, node):
        yield None, "("
        yield node, "if"
        for x in self.visit(node.test):
            yield x
        yield None, "("
        for x in node.body:
            for y in self.visit(x):
                yield y
        yield None, ")"
        if node.orelse:
            yield None, "("
            for x in node.orelse:
                for y in self.visit(x):
                    yield y
            yield None, ")"
        yield None, ")"

    def visit_Return(self, node):
        yield None, "("
        yield node, "return"
        for x in self.visit(node.value):
            yield x
        yield None, ")"

    def visit_FunctionDef(self, node):
        if node.decorator_list:
            raise self.Error(node, "Decorators are not supported")
        args=node.args
        if args.defaults:
            raise self.Error(node, "Default arguments are not supported")
        if args.kwarg:
            raise self.Error(node, "Keyword arguments are not supported")
        if args.vararg:
            raise self.Error(node, "Varargs (*args) are not supported")
        yield None, "("
        yield node, "defproc"
        yield node, node.name
        yield None, "("
        for i, n in enumerate(args.args):
            if not isinstance(n, ast.Name):
                raise self.Error(node, "Only single named arguments are supported (#%d)" % (i,))
            yield None, n.id
        yield None, ")"
        yield None, "("
        for x in node.body:
            for y in self.visit(x):
                yield y
        yield None, ")"
        yield None, ")"
        yield None, "\n"

if __name__=='__main__':
    import optparse
    p=optparse.OptionParser(usage="%prog [options] input.py [output.jmp]")
    p.add_option("--line-numbers", action="store_true", default=False, help="Include line numbers")
    options, args=p.parse_args()

    if len(args) not in (1,2):
        p.error("At least one argument is required")

    c=Compiler()
    c.compile(args[0], linenumbers=options.line_numbers)
