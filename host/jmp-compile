#!/usr/bin/env python

"Turns the subset of Python we support into virtual bytecode for Java code to run"

# We use Python's ast module for the heavy lifting.  It parses the
# target file and we then operate on the resulting abstract syntax
# tree.

import sys
import ast
import linecache
import array
import re

# Get the nicest debugger possible
try:
    from IPython.Debugger import Tracer
    debug_here=Tracer()
    del Tracer
except ImportError:
    import pdb
    debug_here=pdb.set_trace
    del pdb

        
class Label:
    "Instances used to mark locations while generating byte code"
    def __repr__(self):
        return "Label_"+str(id(self))


class Compiler(ast.NodeVisitor):

    # ast classes to string opcodes
    _opmap={
        ast.Add: "ADD",
        ast.Mult: "MULT",
        ast.Div: "DIV",
        ast.Gt: "GT",
        ast.Lt: "LT",
        ast.Eq: "EQ",
        ast.In: "IN",
        ast.UAdd: "UNARY_ADD", 
        }

    class Error(Exception):
        def __init__(self, node, message):
            Exception.__init__(self, message)
            self.message=message
            self.node=node

    # main method to turn .py into .jmp
    def compile(self, options, inputfile, outputfile):
        self.counter=0
        t=ast.parse(open(inputfile, "rb").read(), inputfile)
        ast.fix_missing_locations(t)
        res=[]
        try:
            for node,v  in self.visit(t):
                res.append( (node, v) )
        except self.Error, e:
            if options.traceback:
                x=sys.exc_info()
                import traceback
                traceback.print_exc(x)
            print >> sys.stderr, e.message,"at line",e.node.lineno,"of", inputfile
            print >> sys.stderr, linecache.getline(inputfile, e.node.lineno)+e.node.col_offset*" "+"^"
            sys.exit(2)

        if False:
            # prints raw content before fixups
            for n,v in res:
                print n.lineno if n is not None else "", v

        # integer, string and location tables
        integers=[0]
        strings=[]
        locations={}
        linenotab=[]
        lastlineno=-1
        pos=0
        out=[]
        for n,v in res:
            if isinstance(v, Label):
                locations[v]=pos
                continue
            if n is not None and lastlineno!=n.lineno:
                linenotab.append( (pos, n.lineno) )
                lastlineno=n.lineno
            if not isinstance(v, tuple):
                if v not in opcode_map:
                    print >> sys.stderr, "Internal error: unknown opcode \"%s\"" % (v,)
                    sys.exit(3)
                assert opcode_map[v]<128
                out.append( (n,v) )
                pos+=1
                continue
            pos+=3
            op, val=v
            if op not in opcode_map:
                print >> sys.stderr, "Internal error: unknown opcode \"%s\"" % (op,)
                sys.exit(3)

            opcode=opcode_map[op]

            if is_string_op(opcode):
                assert isinstance(val, (str, unicode))
                if val not in strings:
                    strings.append(val)
                v=(op, strings.index(val))
            elif is_int_op(opcode):
                assert isinstance(val, int)
                if val not in integers:
                    integers.append(val)
                v=(op, integers.index(val))
            elif is_code_op(opcode):
                assert isinstance(val, Label)
            else:
                assert False, "Unhandled opcode "+op
            out.append( (n, v) )
        res=out
        codelen=pos
        if codelen>65535:
            print >> sys.stderr, "Your code is too long - %d instructions" % (codelen,)
            sys.exit(3)
        if linenotab[-1][1]>65535:
            print >> sys.stderr, "Too many lines of code - %d" % (linenotab[-1][1],)
            sys.exit(3)
        
        # fixup labels
        out=[]
        for n,v in res:
            if isinstance(v,tuple) and isinstance(v[1], Label):
                v=v[0],locations[v[1]]
            out.append( (n,v) )
        res=out

        if False:
            # prints after fixups -this should match dumper output
            print ">>> String table"
            for i,v in enumerate(strings):
                print "% 4d" % (i,), v
            print ">>> Integer table"
            for i,v in enumerate(integers):
                print "% 4d" % (i,), v
            print ">>> Line number table"
            for pos,line in linenotab:
                print "% 4d  -> % 4d" % (pos, line)
            pos=0
            for _,v in res:
                for p,l in linenotab:
                    if p>pos:
                        break
                    if p==pos:
                        print "\n# % 4d %s" % (l, linecache.getline(inputfile, l))
                        break
                print "% 5d" % pos, v,
                if isinstance(v, tuple):
                    if is_string_op(v[0]):
                        print "   \t# string", v[1], "=", repr(strings[v[1]]),
                    elif is_int_op(v[0]):
                        print "   \t# int", v[1], "=", integers[v[1]],
                    pos+=3
                else:
                    pos+=1
                print

        ### final output - this could really use a bytes type
        out=array.array("B")
        assert out.itemsize==1, "Bytes must be one byte in length!"
        
        # string table
        if len(strings)>65535:
            print >> sys.stderr, "There are too many strings (%d) - maximum is %d" % (len(strings), 65535)
            sys.exit(3)
        out.append(len(strings)&0xff)
        out.append(len(strings)>>8)
        for s in strings:
            s=s.encode("utf8")
            if len(s)>65535:
                print >> sys.stderr, "One of your strings is too long - %d bytes" % (len(s),)
                sys.exit(3)
            out.append(len(s)&0xff)
            out.append(len(s)>>8)
            out.extend(ord(x) for x in s)

        # integer table
        if len(integers)>65535:
            print >> sys.stderr, "There are too many integers (%d) - maximum is %d" % (len(integers), 65535)
            sys.exit(3)
        out.append(len(integers)&0xff)
        out.append(len(integers)>>8)
        for i in integers:
            out.append(i & 0xff)
            out.append( (i>>8) & 0xff )
            out.append( (i>>16) & 0xff )
            out.append( (i>>24) & 0xff )

        # line number table
        if len(linenotab)>65535:
            print >> sys.stderr, "There are too many lines with code (%d) - maximum is %d" % (len(linenotab), 65535)
            sys.exit(3)
        out.append(len(linenotab)&0xff)
        out.append(len(linenotab)>>8)
        for x,y in linenotab:
            out.append( x & 0xff)
            out.append( x >> 8 )
            out.append( y & 0xff)
            out.append( y >> 8 )

        # The code
        out.append(codelen & 0xff)
        out.append(codelen >> 8 )
        startsize=len(out) # sanity check code size
        for n,v in res:
            if isinstance(v, tuple):
                out.append(self.opcode_for(v[0]))
                out.append(v[1] & 0xff)
                out.append(v[1] >> 8)
            else:
                out.append(self.opcode_for(v))
        assert len(out)-startsize==codelen, "Internal error: code actual size doesn't match calculated size"

        # Write it 
        with open(outputfile, "wb") as f:
            out.tofile(f)
    
    def opcode_for(self, opcode):
        try:
            return opcode_map[opcode]
        except KeyError:
            print >> sys.stderr, "Internal error.  No opcode for \"%s\"" % (opcode,)
            sys.exit(5)

    def generic_visit(self, node):
        raise self.Error(node, "Unsupported syntax "+node.__class__.__name__)

    def visit_Module(self, node):
        for i in node.body:
            for x in self.visit(i):
                yield x

    def visit_Expr(self, node):
        for x in self.visit(node.value):
            yield x
        yield node, "POP_TOP"

    def visit_BoolOp(self, node):
        debug_here()
        pass

    def visit_BinOp(self, node):
        assert len(node.op._fields)==0
        for x in self.visit(node.left):
            yield x
        for x in self.visit(node.right):
            yield x
        yield node, self._opmap[node.op.__class__]

    def visit_Compare(self, node):
        if len(node.ops)!=1:
            raise self.Error(node, "Only one comparison is supported (you can't do x<y<z)")
        for x in self.visit(node.left):
            yield x
        for x in self.visit(node.comparators[0]):
            yield x
        yield node, self._opmap[node.ops[0].__class__]

    def visit_Num(self, node):
        if node.n>0x7fffffff or node.n<-0x80000000:
            raise self.Error(node, "Value is too large")
        yield node, ("PUSH_INT", node.n)

    def visit_Str(self, node):
        yield node, ("PUSH_STR", node.s)

    def visit_NoneType(self, node):
        yield node, "PUSH_NONE"

    def visit_Name(self, node):
        assert len(node.ctx._fields)==0
        yield node, ("LOAD_NAME", node.id)

    def visit_Attribute(self, node):
        assert len(node.ctx._fields)==0
        yield node, ("PUSH_STR", node.attr)
        for x in self.visit(node.value):
            yield x
        yield node, "ATTR"

    def visit_Subscript(self, node):
        assert len(node.ctx._fields)==0
        if isinstance(node.slice, ast.Slice):
            if node.slice.step is not None:
                raise self.Error(node.slice, "Steps not supported in slices")
            if node.slice.upper is None:
                yield None, ("PUSH_INT", -1)
            else:
                for x in self.visit(node.slice.upper):
                    yield x
            if node.slice.lower is None:
                yield None, ("PUSH_INT", 0)
            else:
                for x in self.visit(node.slice.lower):
                    yield x
        else:
            for x in self.visit(node.slice.value):
                yield x

        for x in self.visit(node.value):
            yield x

        if isinstance(node.slice, ast.Slice):
            yield node, "SUBSCRIPT_SLICE"
        else:
            yield node, "SUBSCRIPT"

    def visit_List(self, node):
        assert len(node.ctx._fields)==0
        for x in reversed(node.elts):
            for y in self.visit(x):
                yield y
        yield node, ("PUSH_INT", len(node.elts))
        yield node, "LIST"

    def visit_Dict(self, node):
        for k,v in reversed(zip(node.keys, node.values)):
            for x in self.visit(v):
                yield x
            for x in self.visit(k):
                yield x
        yield node, ("PUSH_INT", len(node.keys))
        yield node, "DICT"

    def visit_Assign(self, node):
        if len(node.targets)!=1:
            raise self.Error(node, "Only assigning to one item at a time is supported")
        target=node.targets[0]
        if not isinstance(target, (ast.Name, ast.Subscript)):
            raise self.Error(target, "That kind of assignment is not supported")
        for x in self.visit(node.value):
            yield x
        if isinstance(target, ast.Name):
            yield node, ("STORE_NAME", target.id)
        else:
            if not isinstance(target.slice, ast.Index):
                raise self.Error(node, "Only simple array/list subscript assignment supported")
            for x in self.visit(target.slice.value):
                yield x
            for x in self.visit(target.value):
                yield x
            yield node, "ASSIGN_INDEX"

    def visit_If(self, node):
        for x in self.visit(node.test):
            yield x
        end=Label()
        elsepart=Label() if node.orelse else None
        yield node, ("IF_FALSE", elsepart if elsepart else end)
        for x in node.body:
            for y in self.visit(x):
                yield y
        if elsepart:
            yield node, ("GOTO", end)
            yield node, elsepart
            for x in node.orelse:
                for y in self.visit(x):
                    yield y
        yield node, end

    def visit_While(self, node):
        if node.orelse:
            raise self.Error(node, "else not supported for while")
        test=Label()
        end=Label()
        yield node, test
        for x in self.visit(node.test):
            yield x
        yield node, ("IF_FALSE", end)
        for x in node.body:
            for y in self.visit(x):
                yield y
        yield node, end
        

    def visit_FunctionDef(self, node):
        if node.decorator_list:
            raise self.Error(node, "Decorators are not supported")
        args=node.args
        if args.defaults:
            raise self.Error(node, "Default arguments are not supported")
        if args.kwarg:
            raise self.Error(node, "Keyword arguments are not supported")
        if args.vararg:
            raise self.Error(node, "Varargs (*args) are not supported")
        body=Label()
        end=Label()
        yield node, ("PUSH_STR", node.name)
        yield node, ("SET_METHOD", body)
        yield node, ("GOTO", end)
        yield node, body
        for i, n in enumerate(args.args):
            if not isinstance(n, ast.Name):
                raise self.Error(n, "Only single named arguments are supported (#%d)" % (i,))
        yield node, ("PUSH_INT", len(args.args))
        yield node, "FUNCTION_PROLOG"
        for n in reversed(args.args):
            yield n, ("STORE_NAME", n.id)
        last=None
        for x in node.body:
            for y in self.visit(x):
                last=y[1]
                yield y
        if last!="RETURN":
            yield None, "PUSH_NONE"
            yield None, "RETURN"
        yield node, end

    def visit_Call(self, node):
        if node.starargs:
            raise self.Error(node, "*args not supported")
        if node.kwargs or node.keywords:
            raise self.Error(node, "Keyword arguments are not supported")
        for x in node.args:
            for y in self.visit(x):
                yield y
        yield node, ("PUSH_INT", len(node.args))
        for x in self.visit(node.func):
            yield x
        yield node, "CALL"

    def visit_Return(self, node):
        for x in self.visit(node.value):
            yield x
        yield node, "RETURN"

def dumper(options, infile):
    getline=lambda x: linecache.getline(options.dump_source, x) if options.dump_source else ""
    data=array.array("B")

    # convenience
    def get16(): # these are always positive
        data.read(infile, 2)
        return (data[-1]<<8)+data[-2]

    def get32(): # could be negative (two's complement)
        data.read(infile, 4)
        i=(data[-1]<<24) + (data[-2]<<16) + (data[-3] << 8) + data[-4]
        if i & 0x80000000:
            i=i-0xffffffff-1
        return i

    infile=open(infile, "rb")

    # string table
    strings=[]
    for i in range(get16()):
        slen=get16()
        data.read(infile, slen)
        string=data[-slen:].tostring().decode("utf8")
        strings.append(string)

    # integer table
    integers=[]
    for i in range(get16()):
        integers.append(get32())

    # line number table
    linenotab=[]
    for i in range(get16()):
        linenotab.append( (get16(), get16()) )

    # code bytes
    codesize=get16()
    data.read(infile, codesize)
    if infile.read()!="":
        print >> sys.stderr, "There is extra gunk at the end of the file - position", len(data)
    code=data[-codesize:]

    if False:
        # prints tables
        print ">>> String table"
        for i,v in enumerate(strings):
            print "% 4d" % (i,), v
        print ">>> Integer table"
        for i,v in enumerate(integers):
            print "% 4d" % (i,), v
        print ">>> Line number table"
        for pos,line in linenotab:
            print "% 4d  -> % 4d" % (pos, line)

    # map ints to strings
    bytecode_map={}
    for k,v in opcode_map.items():
        bytecode_map[v]=k

    # print the code
    pos=0
    while pos<len(code):
        for p,l in linenotab:
            if p>pos:
                break
            if p==pos:
                print "\n# % 4d %s" % (l, getline(l))
                break

        op=code[pos]
        if op>=128:
            val=code[pos+1]+(code[pos+2]<<8)
        
        if op not in bytecode_map:
            print >> sys.stderr, "Unknown opcode %d at position %d" % (op, pos)
            sys.exit(6)
        
        if op<128:
            print "% 5d" % pos, bytecode_map[op]
            pos+=1
        else:
            v=bytecode_map[op]
            print "% 5d" % pos, v, val,
            if is_string_op(op):
                print "   \t# string", val, "=", repr(strings[val]),
            elif is_int_op(op):
                print "   \t# int", val, "=", integers[val],
            print
            pos+=3
        

def java_maintenance(javafile):
    out=[]
    seen=set()
    indent=None

    int_map={}
    for s,v in opcode_map.items():
        int_map[v]=s

    with open(javafile, "rt") as java:
        capturing=False
        for line in java:
            if not capturing and line.lstrip().startswith("// -- check start :"):
                assert len(seen)==0, "Multiple check sections!"
                out.append(line)
                capturing=True
                indent=re.match(r"^(\s*)", line).group(1)
                continue
            if capturing:
                m=re.match(r"\s*case\s+(?P<val>[0-9]+):\s*//\s*(?P<name>\w+)\s*$", line)
                if m:
                    val=int(m.group("val"))
                    if val in seen:
                        print >> sys.stderr, "Second occurrence of",val,": line", len(out)+1
                        sys.exit(3)
                    if val not in int_map:
                        print >> sys.stderr, "Line",len(out)+1,"opcode",val,"/", m.group("name"), "is not known"
                        sys.exit(3)
                    if int_map[val]!=m.group("name"):
                        print >> sys.stderr, "Line",len(out)+1,"opcode",val,"has comment of",m.group("name"),"but should be", int_map[val]
                        sys.exit(3)
                    seen.add(val)
                if line.lstrip().startswith("// -- check end :"):
                    for val,name in sorted(int_map.items()):
                        if val not in seen:
                            out.append("%scase %d: // %s\n" % (indent, val, name))
                    capturing=False
            out.append(line)
    

    if capturing:
        print >> sys.stderr, "End marker not seen in", javafile
        sys.exit(3)

    if not seen:
        print >> sys.stderr, "Special markers not identified in", javafile
        sys.exit(3)

    with open(javafile, "wt") as java:
        java.write("".join(out))
                    
            

# The operations making up our bytecode.  We use a dict not a list so
# that there can be holes/changes without affecting the stability of
# the numbers.  Codes with the upper bit set take an additional two bytes
# of integer (mapping into string or integer tables)
opcode_map={
    "FUNCTION_PROLOG": 0,
    "ADD": 1,
    "MULT": 2,
    "DIV": 3,
    "GT": 4,
    "LT": 5,
    "EQ": 6,
    "IN": 7,
    "UNARY_ADD": 8,
    "RETURN": 9,
    "CALL": 10,
    "POP_TOP": 11,
    "ATTR": 12,
    "UNARY_NEG": 13,
    "SUBSCRIPT": 14,
    "SUBSCRIPT_SLICE": 15,
    "DICT": 16,
    "LIST": 17,
    "PUSH_NONE": 18,

    ### All the following take two byte int value
    # code position
    "SET_METHOD": 128,
    "GOTO": 129,
    "IF_FALSE": 130,

    # strings
    "LOAD_NAME": 160,
    "STORE_NAME": 161,
    "PUSH_STR": 162,

    # integers
    "PUSH_INT": 200,
}

def is_code_op(v):
    return 128<=v<160

def is_string_op(v):
    return 160<=v<200

def is_int_op(v):
    return 200<=v


if __name__=='__main__':
    import os
    import optparse
    p=optparse.OptionParser(usage="""%prog [options] input.py [output.jmp]

Produces JMP format from input.py file. Output goes to input.jmp by
default but you can specify your own output file.

Usage: %prog --dump [options] output.jmp

Dumps an existing .jmp file so you can see the internal representation.""")
    p.add_option("--traceback", action="store_true", default=False, help="Show detailed traceback on compile error")
    p.add_option("--dump", action="store_true", default=False, help="Dump a .jmp file internal representation")
    p.add_option("--dump-source", metavar="INPUT.PY", help="Optional source file that the .jmp was compiled from.  The lines of the source will be intermingled with the output.")
    p.add_option("--java-maintenance", action="store_true", help="Internal:  Used during development to ensuire consistency of implementation")
    p.disable_interspersed_args()
    options, args=p.parse_args()

    if options.dump:
        if len(args)!=1:
            p.error("--dump: One argument expected")
        if options.dump_source:
            if not os.path.exists(options.dump_source):
                p.error("Source file \"%s\" not found" % (options.source,))
        dumper(options, args[0])
    elif options.java_maintenance:
        if len(args)!=1:
            p.error("--java-maintenance: One argument expected")
        java=args[0]
        if not os.path.isfile(java):
            p.error(java+" doesn't exist")
        java_maintenance(java)
    else:
        if len(args) not in (1,2):
            p.error("At least one argument is required")
        c=Compiler()
        c.compile(options, args[0], args[1] if len(args)==2 else os.path.splitext(args[0])[0]+".jmp")
