#!/usr/bin/env python

"Turns the subset of Python we support into virtual bytecode for Java code to run"

# We use Python's ast module for the heavy lifting.  It parses the
# target file and we then operate on the resulting abstract syntax
# tree.

import sys
import ast
import linecache
import array
import re

# Get the nicest debugger possible
try:
    from IPython.Debugger import Tracer
    debug_here=Tracer()
    del Tracer
except ImportError:
    import pdb
    debug_here=pdb.set_trace
    del pdb

        
class Label:
    "Instances used to mark locations while generating byte code"
    def __repr__(self):
        return "Label_"+str(id(self))


class Compiler(ast.NodeVisitor):

    # ast classes to string opcodes
    _opmap={
        ast.Add: "ADD",
        ast.Mult: "MULT",
        ast.Div: "DIV",
        ast.Gt: "GT",
        ast.Lt: "LT",
        ast.Eq: "EQ",
        ast.NotEq: "NOT_EQ",
        ast.In: "IN",
        ast.UAdd: "UNARY_ADD",
        ast.USub: "UNARY_NEG",
        }

    class Error(Exception):
        def __init__(self, node, message):
            Exception.__init__(self, message)
            self.message=message
            self.node=node

    # main method to turn .py into .jmp
    def compile(self, options, inputfile, outputfile):
        self.counter=0
        flags=ast.PyCF_ONLY_AST
        if options.print_function:
            import __future__
            flags|=__future__.print_function.compiler_flag

        t=compile(open(inputfile, "rb").read(), inputfile, 'exec', flags)

        ast.fix_missing_locations(t)
        res=[]
        try:
            for node,v  in self.visit(t):
                res.append( (node, v) )

            if False:
                # prints raw content before fixups
                for n,v in res:
                    print n.lineno if n is not None else "", v

            # string and location tables
            strings=[]
            locations={}
            linenotab=[]
            lastlineno=-1
            pos=0
            out=[]
            for n,v in res:
                if isinstance(v, Label):
                    locations[v]=pos
                    continue
                if n is not None and lastlineno!=n.lineno:
                    linenotab.append( (pos, n.lineno) )
                    lastlineno=n.lineno
                if not isinstance(v, tuple):
                    if v not in opcode_map:
                        print >> sys.stderr, "Internal error: unknown opcode \"%s\"" % (v,)
                        sys.exit(3)
                    assert opcode_map[v]<128
                    out.append( (n,v) )
                    pos+=1
                    continue
                pos+=3
                op, val=v
                if op not in opcode_map:
                    print >> sys.stderr, "Internal error: unknown opcode \"%s\"" % (op,)
                    sys.exit(3)

                opcode=opcode_map[op]

                if is_string_op(opcode):
                    assert isinstance(val, (str, unicode))
                    if val not in strings:
                        strings.append(val)
                    v=(op, strings.index(val))
                    out.append( (n, v) )
                elif is_code_op(opcode):
                    assert isinstance(val, Label)
                    out.append( (n, v) )
                elif op=="PUSH_INT":
                    # turn into two operations depending on value size
                    if val>=0 and val<=0xffff:
                        out.append( (n, v) )
                    elif val<0 and val>=-0xffff:
                        out.append( (n, ("PUSH_INT", -val)) )
                        out.append( (n, "UNARY_NEG") )
                        pos+=1
                    else:
                        out.append( (n, ("PUSH_INT", val&0xffff)) )
                        out.append( (n, ("PUSH_INT_HI", (val>>16)&0xffff)) )
                        pos+=3
                else:
                    assert False, "Unhandled opcode "+op
            res=out
            codelen=pos
            if codelen>65535:
                print >> sys.stderr, "Your code is too long - %d instructions" % (codelen,)
                sys.exit(3)
            if linenotab[-1][1]>65535:
                print >> sys.stderr, "Too many lines of code - %d" % (linenotab[-1][1],)
                sys.exit(3)

            # fixup labels
            out=[]
            for n,v in res:
                if isinstance(v,tuple) and isinstance(v[1], Label):
                    v=v[0],locations[v[1]]
                out.append( (n,v) )
            res=out

            if False:
                # prints after fixups -this should match dumper output
                print ">>> String table"
                for i,v in enumerate(strings):
                    print "% 4d" % (i,), v
                print ">>> Line number table"
                for pos,line in linenotab:
                    print "% 4d  -> % 4d" % (pos, line)
                pos=0
                for _,v in res:
                    for p,l in linenotab:
                        if p>pos:
                            break
                        if p==pos:
                            print "\n# % 4d %s" % (l, linecache.getline(inputfile, l))
                            break
                    print "% 5d" % pos, v,
                    if isinstance(v, tuple):
                        if is_string_op(v[0]):
                            print "   \t# string", v[1], "=", repr(strings[v[1]]),
                        elif is_int_op(v[0]):
                            print "   \t# int", v[1], "=", integers[v[1]],
                        pos+=3
                    else:
                        pos+=1
                    print

            ### final output - this could really use a bytes type
            out=array.array("B")
            assert out.itemsize==1, "Bytes must be one byte in length!"

            # string table
            if len(strings)>65535:
                print >> sys.stderr, "There are too many strings (%d) - maximum is %d" % (len(strings), 65535)
                sys.exit(3)
            out.append(len(strings)&0xff)
            out.append(len(strings)>>8)
            for s in strings:
                s=s.encode("utf8")
                if len(s)>65535:
                    print >> sys.stderr, "One of your strings is too long - %d bytes" % (len(s),)
                    sys.exit(3)
                out.append(len(s)&0xff)
                out.append(len(s)>>8)
                out.extend(ord(x) for x in s)

            # line number table
            if len(linenotab)>65535:
                print >> sys.stderr, "There are too many lines with code (%d) - maximum is %d" % (len(linenotab), 65535)
                sys.exit(3)
            out.append(len(linenotab)&0xff)
            out.append(len(linenotab)>>8)
            for x,y in linenotab:
                out.append( x & 0xff)
                out.append( x >> 8 )
                out.append( y & 0xff)
                out.append( y >> 8 )

            # The code
            out.append(codelen & 0xff)
            out.append(codelen >> 8 )
            startsize=len(out) # sanity check code size
            for n,v in res:
                if isinstance(v, tuple):
                    out.append(self.opcode_for(v[0]))
                    out.append(v[1] & 0xff)
                    out.append(v[1] >> 8)
                else:
                    out.append(self.opcode_for(v))
            assert len(out)-startsize==codelen, "Internal error: code actual size doesn't match calculated size"

            # Write it 
            with open(outputfile, "wb") as f:
                out.tofile(f)

        except self.Error, e:
            if options.traceback:
                x=sys.exc_info()
                import traceback
                traceback.print_exc(x)
            print >> sys.stderr, e.message,"at line",e.node.lineno,"of", inputfile
            print >> sys.stderr, linecache.getline(inputfile, e.node.lineno)+e.node.col_offset*" "+"^"
            sys.exit(2)

    
    def opcode_for(self, opcode):
        try:
            return opcode_map[opcode]
        except KeyError:
            print >> sys.stderr, "Internal error.  No opcode for \"%s\"" % (opcode,)
            sys.exit(5)

    def generic_visit(self, node):
        raise self.Error(node, "Unsupported syntax "+node.__class__.__name__)

    def visit_Module(self, node):
        for i in node.body:
            for x in self.visit(i):
                yield x
        yield None, "EXIT_LOOP"

    def visit_Pass(self, node):
        # needed to force the method to be a generator
        if False:
            yield None

    def visit_Expr(self, node):
        for x in self.visit(node.value):
            yield x
        yield node, "POP_TOP"

    def visit_BoolOp(self, node):
        debug_here()
        pass

    def visit_UnaryOp(self, node):
        for x in self.visit(node.operand):
            yield x
        yield node, self._opmap[node.op.__class__]

    def visit_BinOp(self, node):
        assert len(node.op._fields)==0
        for x in self.visit(node.left):
            yield x
        for x in self.visit(node.right):
            yield x
        yield node, self._opmap[node.op.__class__]

    def visit_Compare(self, node):
        if len(node.ops)!=1:
            raise self.Error(node, "Only one comparison is supported (you can't do x<y<z)")
        for x in self.visit(node.left):
            yield x
        for x in self.visit(node.comparators[0]):
            yield x
        yield node, self._opmap[node.ops[0].__class__]

    def visit_Num(self, node):
        if node.n>0x7fffffff or node.n<-0x80000000:
            raise self.Error(node, "Value is too large")
        yield node, ("PUSH_INT", node.n)

    def visit_Str(self, node):
        yield node, ("PUSH_STR", node.s)

    def visit_NoneType(self, node):
        yield node, "PUSH_NONE"

    def visit_Name(self, node):
        assert len(node.ctx._fields)==0
        # we don't allow true/false/none to be redefined
        if node.id=="True":
            yield node, "PUSH_TRUE"
        elif node.id=="False":
            yield node, "PUSH_FALSE"
        elif node.id=="None":
            yield node, "PUSH_NONE"
        else:
            yield node, ("LOAD_NAME", node.id)

    def visit_Global(self, node):
        for name in node.names:
            yield node, ("GLOBAL", name)

    def visit_Attribute(self, node):
        assert len(node.ctx._fields)==0
        yield node, ("PUSH_STR", node.attr)
        for x in self.visit(node.value):
            yield x
        yield node, "ATTR"

    def visit_Subscript(self, node):
        assert len(node.ctx._fields)==0

        for x in self.visit(node.value):
            yield x

        if isinstance(node.slice, ast.Slice):
            if node.slice.step is not None:
                raise self.Error(node.slice, "Steps not supported in slices")
            if node.slice.upper is None:
                yield None, ("PUSH_INT", -1)
            else:
                for x in self.visit(node.slice.upper):
                    yield x
            if node.slice.lower is None:
                yield None, ("PUSH_INT", 0)
            else:
                for x in self.visit(node.slice.lower):
                    yield x
        else:
            for x in self.visit(node.slice.value):
                yield x

        if isinstance(node.slice, ast.Slice):
            yield node, "SUBSCRIPT_SLICE"
        else:
            yield node, "SUBSCRIPT"

    def visit_List(self, node):
        assert len(node.ctx._fields)==0
        for x in node.elts:
            for y in self.visit(x):
                yield y
        yield node, ("PUSH_INT", len(node.elts))
        yield node, "LIST"

    visit_Tuple=visit_List

    def visit_Dict(self, node):
        for k,v in zip(node.keys, node.values):
            for x in self.visit(v):
                yield x
            for x in self.visit(k):
                yield x
        yield node, ("PUSH_INT", len(node.keys))
        yield node, "DICT"

    def visit_Assign(self, node):
        if len(node.targets)!=1:
            raise self.Error(node, "Only assigning to one item at a time is supported")
        target=node.targets[0]
        if not isinstance(target, (ast.Name, ast.Subscript)):
            raise self.Error(target, "That kind of assignment is not supported")
        for x in self.visit(node.value):
            yield x
        if isinstance(target, ast.Name):
            yield node, ("STORE_NAME", target.id)
        else:
            if not isinstance(target.slice, ast.Index):
                raise self.Error(node, "Only simple array/list subscript assignment supported")
            for x in self.visit(target.slice.value):
                yield x
            for x in self.visit(target.value):
                yield x
            yield node, "ASSIGN_INDEX"

    def visit_If(self, node):
        for x in self.visit(node.test):
            yield x
        end=Label()
        elsepart=Label() if node.orelse else None
        yield node, "BOOL"
        yield node, ("IF_FALSE", elsepart if elsepart else end)
        for x in node.body:
            for y in self.visit(x):
                yield y
        if elsepart:
            yield node, ("GOTO", end)
            yield node, elsepart
            for x in node.orelse:
                for y in self.visit(x):
                    yield y
        yield node, end

    def visit_While(self, node):
        if node.orelse:
            raise self.Error(node, "else not supported for while")
        test=Label()
        end=Label()
        yield node, test
        for x in self.visit(node.test):
            yield x
        yield node, ("IF_FALSE", end)
        for x in node.body:
            for y in self.visit(x):
                yield y
        yield None, ("GOTO", test)
        yield node, end

    def visit_For(self, node):
        if node.orelse:
            raise self.Error(node, "else not supported for 'for'")
        if not isinstance(node.target, ast.Name):
            raise self.Error(node.name, "Can only use single name for 'for' variable")

        loop=Label()
        end=Label()
        for x in self.visit(node.iter):
            yield x
        yield node, "ITER"
        yield node, loop
        yield node, ("NEXT", end)
        yield node.target, ("STORE_NAME", node.target.id)
        for x in node.body:
            for y in self.visit(x):
                yield y
        yield None, ("GOTO", loop)
        yield None, end
        
    def visit_Print(self, node):
        if node.dest is not None:
            raise self.Error(node, "print targets are not supported")
        for x in node.values:
            for y in self.visit(x):
                yield y
        yield node, "PUSH_TRUE" if node.nl else "PUSH_FALSE"
        yield node, ("PUSH_INT", len(node.values))
        yield node, "PRINT"

    def visit_FunctionDef(self, node):
        if node.decorator_list:
            raise self.Error(node, "Decorators are not supported")
        args=node.args
        if args.defaults:
            raise self.Error(node, "Default arguments are not supported")
        if args.kwarg:
            raise self.Error(node, "Keyword arguments are not supported")
        if args.vararg:
            raise self.Error(node, "Varargs (*args) are not supported")
        body=Label()
        end=Label()
        yield node, ("PUSH_STR", node.name)
        yield node, ("SET_METHOD", body)
        yield node, ("GOTO", end)
        yield node, body
        for i, n in enumerate(args.args):
            if not isinstance(n, ast.Name):
                raise self.Error(n, "Only single named arguments are supported (#%d)" % (i,))
        yield node, ("PUSH_INT", len(args.args))
        yield node, "FUNCTION_PROLOG"
        for n in reversed(args.args):
            yield n, ("STORE_NAME", n.id)
        last=None
        for x in node.body:
            for y in self.visit(x):
                last=y[1]
                yield y
        if last!="RETURN":
            yield None, "PUSH_NONE"
            yield None, "RETURN"
        yield node, end

    def visit_Call(self, node):
        if node.starargs:
            raise self.Error(node, "*args not supported")
        if node.kwargs or node.keywords:
            raise self.Error(node, "Keyword arguments are not supported")
        for x in node.args:
            for y in self.visit(x):
                yield y
        yield node, ("PUSH_INT", len(node.args))
        for x in self.visit(node.func):
            yield x
        yield node, "CALL"

    def visit_Return(self, node):
        for x in self.visit(node.value):
            yield x
        yield node, "RETURN"

def dumper(options, infile):
    getline=lambda x: linecache.getline(options.dump_source, x) if options.dump_source else ""
    data=array.array("B")

    # convenience
    def get16(): # these are always positive
        data.read(infile, 2)
        return (data[-1]<<8)+data[-2]

    def get32(): # could be negative (two's complement)
        data.read(infile, 4)
        i=(data[-1]<<24) + (data[-2]<<16) + (data[-3] << 8) + data[-4]
        if i & 0x80000000:
            i=i-0xffffffff-1
        return i

    infile=open(infile, "rb")

    # string table
    strings=[]
    for i in range(get16()):
        slen=get16()
        data.read(infile, slen)
        string=data[-slen:].tostring().decode("utf8")
        strings.append(string)

    # line number table
    linenotab=[]
    for i in range(get16()):
        linenotab.append( (get16(), get16()) )

    # code bytes
    codesize=get16()
    data.read(infile, codesize)
    if infile.read()!="":
        print >> sys.stderr, "There is extra gunk at the end of the file - position", len(data)
    code=data[-codesize:]

    if False:
        # prints tables
        print ">>> String table"
        for i,v in enumerate(strings):
            print "% 4d" % (i,), v
        print ">>> Line number table"
        for pos,line in linenotab:
            print "% 4d  -> % 4d" % (pos, line)

    # map ints to strings
    bytecode_map={}
    for k,v in opcode_map.items():
        bytecode_map[v]=k

    # print the code
    pos=0
    while pos<len(code):
        for p,l in linenotab:
            if p>pos:
                break
            if p==pos:
                print "\n# % 4d %s" % (l, getline(l))
                break

        op=code[pos]
        if op>=128:
            val=code[pos+1]+(code[pos+2]<<8)
        
        if op not in bytecode_map:
            print >> sys.stderr, "Unknown opcode %d at position %d" % (op, pos)
            sys.exit(6)
        
        if op<128:
            print "% 5d" % pos, bytecode_map[op]
            pos+=1
        else:
            v=bytecode_map[op]
            print "% 5d" % pos, v, val,
            if is_string_op(op):
                print "   \t# string", val, "=", repr(strings[val]),
            print
            pos+=3
        

def java_maintenance(javafile):
    out=[]
    seen=set()
    indent=None

    int_map={}
    for s,v in opcode_map.items():
        int_map[v]=s

    with open(javafile, "rt") as java:
        capturing=False
        for line in java:
            if not capturing and line.lstrip().startswith("// -- check start :"):
                assert len(seen)==0, "Multiple check sections!"
                out.append(line)
                capturing=True
                indent=re.match(r"^(\s*)", line).group(1)
                continue
            if capturing:
                m=re.match(r"\s*case\s+(?P<val>[0-9]+):\s*//\s*(?P<name>\w+)\s*$", line)
                if m:
                    val=int(m.group("val"))
                    if val in seen:
                        print >> sys.stderr, "Second occurrence of",val,": line", len(out)+1
                        sys.exit(3)
                    if val not in int_map:
                        print >> sys.stderr, "Line",len(out)+1,"opcode",val,"/", m.group("name"), "is not known"
                        sys.exit(3)
                    if int_map[val]!=m.group("name"):
                        print >> sys.stderr, "Line",len(out)+1,"opcode",val,"has comment of",m.group("name"),"but should be", int_map[val]
                        sys.exit(3)
                    seen.add(val)
                if line.lstrip().startswith("// -- check end :"):
                    for val,name in sorted(int_map.items()):
                        if val not in seen:
                            out.append("%scase %d: // %s\n" % (indent, val, name))
                    capturing=False
            out.append(line)
    

    if capturing:
        print >> sys.stderr, "End marker not seen in", javafile
        sys.exit(3)

    if not seen:
        print >> sys.stderr, "Special markers not identified in", javafile
        sys.exit(3)

    with open(javafile, "wt") as java:
        java.write("".join(out))
                    
            

# The operations making up our bytecode.  We use a dict not a list so
# that there can be holes/changes without affecting the stability of
# the numbers.  Codes with the upper bit set take an additional two bytes
# of integer (mapping into string or integer tables)
opcode_map={
    "FUNCTION_PROLOG": 0,
    "ADD": 1,
    "MULT": 2,
    "DIV": 3,
    "GT": 4,
    "LT": 5,
    "EQ": 6,
    "IN": 7,
    "UNARY_ADD": 8,
    "RETURN": 9,
    "CALL": 10,
    "POP_TOP": 11,
    "ATTR": 12,
    "UNARY_NEG": 13,
    "SUBSCRIPT": 14,
    "SUBSCRIPT_SLICE": 15,
    "DICT": 16,
    "LIST": 17,
    "PUSH_NONE": 18,
    "EXIT_LOOP": 19,
    "STR": 20,
    "PUSH_TRUE": 21,
    "PUSH_FALSE": 22,
    "PRINT": 23,
    "BOOL": 24,
    "ITER": 25,
    "NOT_EQ": 26,

    ### All the following take two byte int value
    # code position
    "SET_METHOD": 128,
    "GOTO": 129,
    "IF_FALSE": 130,
    "NEXT": 131,

    # strings
    "LOAD_NAME": 160,
    "STORE_NAME": 161,
    "PUSH_STR": 162,
    "GLOBAL": 163,

    # integers
    "PUSH_INT": 200,
    "PUSH_INT_HI": 201,
}

def is_code_op(v):
    return 128<=v<160

def is_string_op(v):
    return 160<=v<200

def is_int_op(v):
    return 200<=v


if __name__=='__main__':
    import os
    import optparse
    p=optparse.OptionParser(usage="""%prog [options] file[s]""")

    g=optparse.OptionGroup(p, "Compiling", """Supply a filename
containing Python code.  By default the output is written
alongside the input file with a .jmp extension.  Supply a second
filename to override where the output goes.""")

    g.add_option("--traceback", action="store_true", default=False, help="Show detailed traceback on compile error")
    g.add_option("--print-function", action="store_true", default=sys.version_info>(3,), help="'print' is a function (Python 3 style) [%default]")
    p.add_option_group(g)

    g=optparse.OptionGroup(p, "Dumping", """Shows the internal representation of .jmp files""")
    g.add_option("--dump", action="store_true", default=False, help="Enables dump mode")
    g.add_option("--dump-source", metavar="INPUT.PY", help="Optional source file that the .jmp was compiled from.  The lines of the source will be intermingled with the output.")
    p.add_option_group(g)

    g=optparse.OptionGroup(p, "Internal developer")
    g.add_option("--java-maintenance", action="store_true", help="Used during development to ensure consistency of implementation")
    p.add_option_group(g)

    p.disable_interspersed_args()
    options, args=p.parse_args()

    if options.dump:
        if len(args)!=1:
            p.error("--dump: One argument expected")
        if options.dump_source:
            if not os.path.exists(options.dump_source):
                p.error("Source file \"%s\" not found" % (options.source,))
        dumper(options, args[0])
    elif options.java_maintenance:
        if len(args)!=1:
            p.error("--java-maintenance: One argument expected")
        java=args[0]
        if not os.path.isfile(java):
            p.error(java+" doesn't exist")
        java_maintenance(java)
    else:
        if len(args) not in (1,2):
            p.error("At least one argument is required")
        c=Compiler()
        c.compile(options, args[0], args[1] if len(args)==2 else os.path.splitext(args[0])[0]+".jmp")
